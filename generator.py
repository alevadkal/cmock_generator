#! /usr/bin/python3

# MIT License

# Copyright (c) 2020 alevadkal

# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:

# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.

# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

import sys
import json
import re
import string
import os
import datetime

# =======================================================================================
# FUNCTIONS PARSING
# =======================================================================================

RE_SPACES=re.compile(r' +')

TARGET_FUNC=re.compile(r'\|.*')
def parsetarget_func_name(prototype):
    target = TARGET_FUNC.findall(prototype);
    if(len(target) == 0):
        return {}
    return {"target": target[0].strip('| ')}

RE_TYPE_AND_NAME=re.compile(r'^[^(]+')
def parse_type_and_name(prototype):
    fields=RE_TYPE_AND_NAME.findall(prototype)[0].split()
    return {
        "name": fields[-1],
        "type": ' '.join(fields[:-1])
    }

def parse_param_type_and_name(param)->dict:
    param = param.strip()
    if(param == '...'):
        return {'type':'...'}
    fields = param.split()
    return {
        "name": fields[-1],
        "type": ' '.join(fields[:-1])
    }

RE_PARAMS=re.compile(r'\([^)]*\)')
def parse_params(prototype):
    params = RE_PARAMS.findall(prototype)[0].strip(')(').strip()
    if(params == '' or params == 'void'):
        return []
    return [parse_param_type_and_name(param) for param in params.split(',')]

def parse_func_prototype(prototype):
    prototype = RE_SPACES.sub(prototype.replace('*', '* ').replace(' *', '*'), ' ')
    func = parse_type_and_name(prototype)
    func['params'] = parse_params(prototype)
    return {**func, **parsetarget_func_name(prototype)}

def read_config(file_name):
    config = json.load(open(file_name))
    config['functions'] = [parse_func_prototype(func) for func in config['functions']]
    
    return config
# =======================================================================================
# CODE GENERATION
# =======================================================================================

FILE_HEADER="""
# MIT License

# Copyright (c) {} alevadkal

# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:

# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.

# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

# ##########################################################################
#  WARNING!!! AUTOGENERATED FILE. DON'T EDIT. WILL BE REGENERATE IF CHANGED.
# ##########################################################################
""".format(datetime.date.today().year)

def is_va_param(param):
    return param['type'] == '...'

def is_va_func(func):
    return len(func['params']) and is_va_param(func['params'][-1])

def is_void_func(func):
    return func['type'] == 'void'

def f_param_defenition(func):
    return ', '.join([
        '...' if is_va_param(param) else ' '.join([param['type'], param['name']])
        for param in func['params']
    ])

def get_func_decl_wrap(func):
    return "{f_type} __wrap_{f_name}({f_params})".format(
        f_type = func['type'],
        f_name = func['name'],
        f_params = f_param_defenition(func)
    )

def get_target(config, func):
    target = func['target'] if 'target' in func.keys() else "__real_" + func['name']
    return "__real_" + target if target in [func['name'] for func in config['functions']] else target


HPP_HEADER="""
{file_header}
#ifndef {NAME}_HPP
#define {NAME}_HPP

#include <gmock/gmock.h>
#include <stdarg.h>
{includes}

class {name} 
{{
public:
    {name}();
    virtual ~{name}();

    static {name}& instance();
    static bool exist();

    {mock_defenitions}

    {name}(const {name}&) = delete;
    {name} operator=(const {name}&) = delete;
}};

extern "C"
{{
    {real_func_defenition}
}}

#endif // {NAME}_HPP
"""
def get_header_content(config):
    functions = config['functions']
    return HPP_HEADER.format(
        file_header = FILE_HEADER.replace('# ','// '),
        NAME=config['name'].upper(),
        name=config['name'],
        includes = '\n'.join(['#include "{}"'.format(include) for include in config['include']]),
        mock_defenitions = '\n    '.join([
            "MOCK_METHOD{param_number}({f_name}, {f_type}({f_param_def}));".format(
                param_number = len(func['params']),
                f_name = func['name'],
                f_type = func['type'],
                f_param_def = f_param_defenition(func).replace("...", 'va_list args')
            )
            for func in functions
        ]),
        real_func_defenition=";\n    ".join([
            "{f_type} __real_{f_name}({f_params})".format(
                f_type = func['type'],
                f_name = func['name'],
                f_params = f_param_defenition(func)
            )
            for func in functions
        ])+";"
    )

CPP_SOURCE="""
{file_header}
#include "{name}.hpp"

using ::testing::_;
using ::testing::Invoke;

static {name}* self = nullptr;


{name}::{name}()
{{
    if (exist()) {{
        std::cerr << "FATAL_ERROR: mock " << __PRETTY_FUNCTION__ << " already exist" << std::endl;
        exit(13);
    }}
    self = this;
    {setup_default_behaviour}
}}

{name}::~{name}()
{{
    self = nullptr;
}}

{name}& {name}::instance()
{{
    if (!exist()) {{
        std::cerr << "FATAL_ERROR: mock " << __PRETTY_FUNCTION__ << " not exist" << std::endl;
        exit(13);
    }}
    return *self;
}}
bool exist()
{{
    return self != nullptr;
}}

extern "C"
{{

    {wrapper_functions_declaration}

}}

{wrapper_functions_implimentation}

"""
def get_source_content(config):
    functions = config['functions']
    return CPP_SOURCE.format(
        file_header = FILE_HEADER.replace('# ','// '),
        name = config['name'],
        setup_default_behaviour='\n    '.join([
            "ON_CALL({name}::instance(), {f_name}({f_matchers})).WillByDefault(Invoke({target}));". format(
                name = config['name'],
                f_name = func['name'],
                target = get_target(config, func),
                f_matchers=', '.join(['_' for x in func['params']])
            )
            for func in functions
        ]),
        wrapper_functions_declaration=";\n    ".join([get_func_decl_wrap(func) for func in functions]) + ";",
        wrapper_functions_implimentation='\n'.join([
            "\n".join([
                "{wrapper_func_defenition}",
                "{{{va_args}",
                "    if ({mock_name}::exist()) {{",
                "        {return_value_create}{mock_name}::instance().{f_name}({param_recieve});{va_end}{return_answer}",
                "    }} else {{",
                "        {return_value_create}{target}({param_recieve});{va_end}{return_answer}",
                "    }}",
                "}}",
                "",
            ]).format(
                f_type = func['type'],
                f_name = func['name'],
                mock_name = config['name'],
                va_args = '\n    '.join([
                    '',
                    'va_list args;',
                    'va_start(args, {});'.format(func['params'][-2]['name'])
                ]) if is_va_func(func) else '',
                va_end = '\n        va_end(args);' if is_va_func(func) else '',
                wrapper_func_defenition = get_func_decl_wrap(func),
                return_value_create='' if is_void_func(func) else '{} answer = '.format(func['type']) if is_va_func(func)  else 'return ',
                param_recieve=', '.join([
                    'args' if is_va_param(param) else param['name'] 
                    for param in func['params']
                ]),
                return_answer = '' if is_void_func(func) or not is_va_func(func) else "\n        return answer;",
                target=get_target(config, func)
            ) 
            for func in functions])
    )

CMAKE_LISTS_TXT="""
{file_header}
add_library({name} EXCLUDE_FROM_ALL STATIC src/{name}.cpp)
target_include_directories({name} PUBLIC include)
target_link_libraries({name} PUBLIC gmock gmock_main)
target_link_options({name} PUBLIC
    {wrap_flags}
)
"""
def get_cmakelists_content(config):
    return CMAKE_LISTS_TXT.format(
        file_header = FILE_HEADER,
        name = config['name'],
        wrap_flags = '\n    '.join([
            '"--Wl,--wrap={}"'.format(func['name']) for func in config['functions']
        ])
    )

def store_data(content_maker, filename, config):
    directory = os.path.dirname(filename)
    if directory != '':
        os.makedirs(directory, exist_ok=True)
    open(filename, 'w').write(content_maker(config))

def main():
    name = sys.argv[1]
    config_name = sys.argv[2]
    config = read_config(config_name)
    config['name'] = name
    
    #print(json.dumps(config, indent=4))
    #print(get_header_content(config))
    #print(get_source_content(config))
    #print(get_cmakelists_content(config))
    
    store_data(get_header_content, "include/{}.hpp".format(name), config)
    store_data(get_source_content, "src/{}.cpp".format(name), config)
    store_data(get_cmakelists_content, "CMakeLists.txt", config)

if __name__ == "__main__":
    main()
